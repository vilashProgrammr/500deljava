"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/********************************************************************************
 * Copyright (C) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var inversify_1 = require("inversify");
var uri_1 = require("@theia/core/lib/common/uri");
var core_1 = require("@theia/core");
var browser_1 = require("@theia/core/lib/browser");
var browser_2 = require("@theia/editor/lib/browser");
var common_1 = require("../common");
var git_commands_1 = require("./git-commands");
var git_repository_tracker_1 = require("./git-repository-tracker");
var git_quick_open_service_1 = require("./git-quick-open-service");
var git_sync_service_1 = require("./git-sync-service");
var browser_3 = require("@theia/workspace/lib/browser");
var git_prompt_1 = require("../common/git-prompt");
var browser_4 = require("@theia/scm/lib/browser");
var git_repository_provider_1 = require("./git-repository-provider");
var git_commit_message_validator_1 = require("../browser/git-commit-message-validator");
var git_error_handler_1 = require("../browser/git-error-handler");
var scm_widget_1 = require("@theia/scm/lib/browser/scm-widget");
var git_decorator_1 = require("./git-decorator");
exports.EDITOR_CONTEXT_MENU_GIT = __spread(browser_2.EDITOR_CONTEXT_MENU, ['3_git']);
var GIT_COMMANDS;
(function (GIT_COMMANDS) {
    GIT_COMMANDS.CLONE = {
        id: 'git.clone',
        label: 'Git: Clone...'
    };
    GIT_COMMANDS.FETCH = {
        id: 'git.fetch',
        label: 'Git: Fetch...'
    };
    GIT_COMMANDS.PULL_DEFAULT = {
        id: 'git.pull.default',
        label: 'Git: Pull'
    };
    GIT_COMMANDS.PULL = {
        id: 'git.pull',
        label: 'Git: Pull from...'
    };
    GIT_COMMANDS.PUSH_DEFAULT = {
        id: 'git.push.default',
        label: 'Git: Push'
    };
    GIT_COMMANDS.PUSH = {
        id: 'git.push',
        label: 'Git: Push to...'
    };
    GIT_COMMANDS.MERGE = {
        id: 'git.merge',
        label: 'Git: Merge...'
    };
    GIT_COMMANDS.CHECKOUT = {
        id: 'git.checkout',
        label: 'Git: Checkout'
    };
    GIT_COMMANDS.COMMIT = {
        id: 'git.commit.all',
        tooltip: 'Commit all the staged changes',
        text: 'Commit',
    };
    GIT_COMMANDS.COMMIT_ADD_SIGN_OFF = {
        id: 'git-commit-add-sign-off',
        label: 'Add Signed-off-by',
        iconClass: 'fa fa-pencil-square-o',
        category: 'Git'
    };
    GIT_COMMANDS.COMMIT_AMEND = {
        id: 'git.commit.amend'
    };
    GIT_COMMANDS.COMMIT_SIGN_OFF = {
        id: 'git.commit.signOff'
    };
    GIT_COMMANDS.CHANGE_REPOSITORY = {
        id: 'git.change.repository',
        label: 'Git: Change Repository...'
    };
    GIT_COMMANDS.OPEN_FILE = {
        id: 'git.open.file',
        category: 'Git',
        label: 'Open File',
        iconClass: 'theia-open-file-icon'
    };
    GIT_COMMANDS.OPEN_CHANGED_FILE = {
        id: 'git.open.changed.file',
        category: 'Git',
        label: 'Open File',
        iconClass: 'open-file'
    };
    GIT_COMMANDS.OPEN_CHANGES = {
        id: 'git.open.changes',
        category: 'Git',
        label: 'Open Changes',
        iconClass: 'theia-open-change-icon'
    };
    GIT_COMMANDS.SYNC = {
        id: 'git.sync',
        label: 'Git: Sync'
    };
    GIT_COMMANDS.PUBLISH = {
        id: 'git.publish',
        label: 'Git: Publish Branch'
    };
    GIT_COMMANDS.STAGE = {
        id: 'git.stage',
        category: 'Git',
        label: 'Stage Changes',
        iconClass: 'fa fa-plus'
    };
    GIT_COMMANDS.STAGE_ALL = {
        id: 'git.stage.all',
        category: 'Git',
        label: 'Stage All Changes',
        iconClass: 'fa fa-plus',
    };
    GIT_COMMANDS.UNSTAGE = {
        id: 'git.unstage',
        iconClass: 'fa fa-minus',
        category: 'Git',
        label: 'Unstage Changes'
    };
    GIT_COMMANDS.UNSTAGE_ALL = {
        id: 'git.unstage.all',
        iconClass: 'fa fa-minus',
        category: 'Git',
        label: 'Unstage All',
    };
    GIT_COMMANDS.DISCARD = {
        id: 'git.discard',
        iconClass: 'fa fa-undo',
        category: 'Git',
        label: 'Discard Changes'
    };
    GIT_COMMANDS.DISCARD_ALL = {
        id: 'git.discard.all',
        iconClass: 'fa fa-undo',
        category: 'Git',
        label: 'Discard All Changes',
    };
    GIT_COMMANDS.STASH = {
        id: 'git.stash',
        category: 'Git',
        label: 'Stash...'
    };
    GIT_COMMANDS.APPLY_STASH = {
        id: 'git.stash.apply',
        category: 'Git',
        label: 'Apply Stash...'
    };
    GIT_COMMANDS.APPLY_LATEST_STASH = {
        id: 'git.stash.apply.latest',
        category: 'Git',
        label: 'Apply Latest Stash'
    };
    GIT_COMMANDS.POP_STASH = {
        id: 'git.stash.pop',
        category: 'Git',
        label: 'Pop Stash...'
    };
    GIT_COMMANDS.POP_LATEST_STASH = {
        id: 'git.stash.pop.latest',
        category: 'Git',
        label: 'Pop Latest Stash'
    };
    GIT_COMMANDS.DROP_STASH = {
        id: 'git.stash.drop',
        category: 'Git',
        label: 'Drop Stash...'
    };
    GIT_COMMANDS.REFRESH = {
        id: 'git-refresh',
        label: 'Refresh',
        iconClass: 'fa fa-refresh',
        category: 'Git'
    };
})(GIT_COMMANDS = exports.GIT_COMMANDS || (exports.GIT_COMMANDS = {}));
var GitContribution = /** @class */ (function () {
    function GitContribution() {
        this.toDispose = new core_1.DisposableCollection();
        this.icons = new Map();
        this.dirtyRepositories = [];
        this.scmProviders = [];
    }
    GitContribution_1 = GitContribution;
    GitContribution.prototype.onStart = function () {
        var _this = this;
        this.repositoryProvider.allRepositories.forEach(function (repository) { return _this.registerScmProvider(repository); });
        this.dirtyRepositories = this.repositoryProvider.allRepositories;
        this.scmService.onDidChangeSelectedRepositories(function (scmRepository) {
            var repository = _this.repositoryProvider.allRepositories.find(function (repo) {
                if (scmRepository) {
                    return repo.localUri === scmRepository.provider.rootUri;
                }
                else {
                    return false;
                }
            });
            if (repository) {
                _this.repositoryProvider.selectedRepository = repository;
            }
            else {
                _this.statusBar.removeElement(GitContribution_1.GIT_CHECKOUT);
                _this.statusBar.removeElement(GitContribution_1.GIT_SYNC_STATUS);
            }
        });
        this.repositoryTracker.onGitEvent(function (event) {
            _this.checkNewOrRemovedRepositories();
            var status = event.status;
            var branch = status.branch ? status.branch : status.currentHead ? status.currentHead.substring(0, 8) : 'NO-HEAD';
            var dirty = '';
            if (status.changes.length > 0) {
                var conflicts = _this.hasConflicts(status.changes);
                var staged = _this.allStaged(status.changes);
                if (conflicts || staged) {
                    if (conflicts) {
                        dirty = '!';
                    }
                    else if (staged) {
                        dirty = '+';
                    }
                }
                else {
                    dirty = '*';
                }
            }
            var scmProvider = _this.scmProviders.find(function (provider) { return provider.rootUri === event.source.localUri; });
            if (scmProvider) {
                var provider_1 = scmProvider;
                _this.getGroups(status, provider_1).then(function (groups) {
                    provider_1.groups = groups;
                    provider_1.fireChangeStatusBarCommands([{
                            id: GitContribution_1.GIT_CHECKOUT,
                            text: "$(code-fork) " + branch + dirty,
                            command: GIT_COMMANDS.CHECKOUT.id
                        }]);
                    provider_1.fireChangeResources();
                    _this.updateSyncStatusBarEntry(event.source.localUri);
                });
            }
        });
        this.syncService.onDidChange(function () { return _this.updateSyncStatusBarEntry(_this.repositoryProvider.selectedRepository
            ? _this.repositoryProvider.selectedRepository.localUri
            : undefined); });
    };
    GitContribution.prototype.getGroups = function (status, provider) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, _a, groups, stagedChanges, unstagedChanges, mergeChanges, _b, _c, change, _d, _e, _f, _g, _h, _j;
            return __generator(this, function (_k) {
                switch (_k.label) {
                    case 0:
                        groups = [];
                        stagedChanges = [];
                        unstagedChanges = [];
                        mergeChanges = [];
                        if (status) {
                            try {
                                for (_b = __values(status.changes), _c = _b.next(); !_c.done; _c = _b.next()) {
                                    change = _c.value;
                                    if (common_1.GitFileStatus[common_1.GitFileStatus.Conflicted.valueOf()] !== common_1.GitFileStatus[change.status]) {
                                        if (change.staged) {
                                            stagedChanges.push(change);
                                        }
                                        else {
                                            unstagedChanges.push(change);
                                        }
                                    }
                                    else {
                                        if (!change.staged) {
                                            mergeChanges.push(change);
                                        }
                                    }
                                }
                            }
                            catch (e_1_1) { e_1 = { error: e_1_1 }; }
                            finally {
                                try {
                                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                }
                                finally { if (e_1) throw e_1.error; }
                            }
                        }
                        if (!(stagedChanges.length > 0)) return [3 /*break*/, 2];
                        _e = (_d = groups).push;
                        return [4 /*yield*/, this.getGroup('Staged changes', provider, stagedChanges)];
                    case 1:
                        _e.apply(_d, [_k.sent()]);
                        _k.label = 2;
                    case 2:
                        if (!(unstagedChanges.length > 0)) return [3 /*break*/, 4];
                        _g = (_f = groups).push;
                        return [4 /*yield*/, this.getGroup('Changes', provider, unstagedChanges)];
                    case 3:
                        _g.apply(_f, [_k.sent()]);
                        _k.label = 4;
                    case 4:
                        if (!(mergeChanges.length > 0)) return [3 /*break*/, 6];
                        _j = (_h = groups).push;
                        return [4 /*yield*/, this.getGroup('Merged Changes', provider, mergeChanges)];
                    case 5:
                        _j.apply(_h, [_k.sent()]);
                        _k.label = 6;
                    case 6: return [2 /*return*/, groups];
                }
            });
        });
    };
    GitContribution.prototype.getGroup = function (label, provider, changes) {
        return __awaiter(this, void 0, void 0, function () {
            var sort, group, scmResources;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sort = function (l, r) {
                            return l.sourceUri.toString().substring(l.sourceUri.toString().lastIndexOf('/')).localeCompare(r.sourceUri.toString().substring(r.sourceUri.toString().lastIndexOf('/')));
                        };
                        group = {
                            handle: 0,
                            sourceControlHandle: 0,
                            label: label,
                            id: label,
                            provider: provider,
                            onDidChange: provider.onDidChange,
                            resources: [],
                            dispose: function () { }
                        };
                        return [4 /*yield*/, Promise.all(changes.map(function (change) { return __awaiter(_this, void 0, void 0, function () {
                                var icon, resource, open;
                                var _this = this;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.labelProvider.getIcon(new uri_1.default(change.uri))];
                                        case 1:
                                            icon = _a.sent();
                                            resource = {
                                                group: group,
                                                sourceUri: new uri_1.default(change.uri),
                                                decorations: {
                                                    icon: icon,
                                                    letter: common_1.GitFileStatus.toAbbreviation(change.status, change.staged),
                                                    color: git_decorator_1.GitDecorator.getDecorationColor(change.status),
                                                    tooltip: common_1.GitFileStatus.toString(change.status)
                                                },
                                                sourceControlHandle: 0,
                                                groupHandle: 0,
                                                handle: 0,
                                                open: function () {
                                                    return __awaiter(this, void 0, void 0, function () {
                                                        return __generator(this, function (_a) {
                                                            open();
                                                            return [2 /*return*/];
                                                        });
                                                    });
                                                }
                                            };
                                            open = function () { return __awaiter(_this, void 0, void 0, function () {
                                                var uriToOpen;
                                                return __generator(this, function (_a) {
                                                    uriToOpen = this.gitCommands.getUriToOpen(change);
                                                    this.editorManager.open(uriToOpen, { mode: 'reveal' });
                                                    return [2 /*return*/];
                                                });
                                            }); };
                                            return [2 /*return*/, resource];
                                    }
                                });
                            }); }))];
                    case 1:
                        scmResources = _a.sent();
                        scmResources.sort(sort);
                        scmResources.forEach(function (resource) { return group.resources.push(resource); });
                        return [2 /*return*/, group];
                }
            });
        });
    };
    /** Detect and handle added or removed repositories. */
    GitContribution.prototype.checkNewOrRemovedRepositories = function () {
        var _this = this;
        var added = this.repositoryProvider
            .allRepositories
            .find(function (repo) { return _this.dirtyRepositories.every(function (dirtyRepo) { return dirtyRepo.localUri !== repo.localUri; }); });
        if (added) {
            this.registerScmProvider(added);
            this.dirtyRepositories.push(added);
        }
        var removed = this.dirtyRepositories
            .find(function (dirtyRepo) { return _this.repositoryProvider.allRepositories.every(function (repo) { return repo.localUri !== dirtyRepo.localUri; }); });
        if (removed) {
            var i = this.dirtyRepositories.indexOf(removed, 0);
            if (i > -1) {
                this.dirtyRepositories.splice(i, 1);
            }
            var removedScmRepo = this.scmService.repositories.find(function (scmRepo) { return scmRepo.provider.rootUri === removed.localUri; });
            if (removedScmRepo) {
                removedScmRepo.dispose();
                var index = this.scmProviders.indexOf(removedScmRepo.provider);
                if (index > -1) {
                    this.scmProviders.splice(index, 1);
                }
            }
        }
    };
    GitContribution.prototype.registerScmProvider = function (repository) {
        var _this = this;
        var uri = repository.localUri;
        var disposableCollection = [];
        var onDidChangeResourcesEmitter = new core_1.Emitter();
        var onDidChangeRepositoryEmitter = new core_1.Emitter();
        disposableCollection.push(onDidChangeRepositoryEmitter);
        disposableCollection.push(onDidChangeResourcesEmitter);
        var amendSupport = new GitAmendSupport(repository, this.git);
        var provider = new ScmProviderImpl('Git', uri.substring(uri.lastIndexOf('/') + 1), uri, amendSupport);
        this.scmProviders.push(provider);
        var repo = this.scmService.registerScmProvider(provider, disposableCollection);
        repo.input.placeholder = 'Commit message';
        repo.input.validateInput = function (input) { return __awaiter(_this, void 0, void 0, function () {
            var validate, message, status_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.commitMessageValidator.validate(input)];
                    case 1:
                        validate = _a.sent();
                        if (validate) {
                            message = validate.message, status_1 = validate.status;
                            return [2 /*return*/, { message: message, type: status_1 }];
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        return repo;
    };
    GitContribution.prototype.registerMenus = function (menus) {
        [GIT_COMMANDS.FETCH, GIT_COMMANDS.PULL_DEFAULT, GIT_COMMANDS.PULL, GIT_COMMANDS.PUSH_DEFAULT, GIT_COMMANDS.PUSH, GIT_COMMANDS.MERGE].forEach(function (command) {
            return menus.registerMenuAction(scm_widget_1.ScmWidget.ContextMenu.FIRST_GROUP, {
                commandId: command.id,
                label: command.label.slice('Git: '.length)
            });
        });
        menus.registerMenuAction(scm_widget_1.ScmWidget.ContextMenu.INPUT_GROUP, {
            commandId: GIT_COMMANDS.COMMIT_AMEND.id,
            label: 'Commit (Amend)'
        });
        menus.registerMenuAction(scm_widget_1.ScmWidget.ContextMenu.INPUT_GROUP, {
            commandId: GIT_COMMANDS.COMMIT_SIGN_OFF.id,
            label: 'Commit (Signed Off)'
        });
        menus.registerMenuAction(scm_widget_1.ScmWidget.ContextMenu.BATCH, {
            commandId: GIT_COMMANDS.STAGE_ALL.id,
            label: 'Stage All Changes'
        });
        menus.registerMenuAction(scm_widget_1.ScmWidget.ContextMenu.BATCH, {
            commandId: GIT_COMMANDS.UNSTAGE_ALL.id,
            label: 'Unstage All Changes'
        });
        menus.registerMenuAction(scm_widget_1.ScmWidget.ContextMenu.BATCH, {
            commandId: GIT_COMMANDS.DISCARD_ALL.id,
            label: 'Discard All Changes'
        });
        menus.registerMenuAction(browser_2.EditorContextMenu.NAVIGATION, {
            commandId: GIT_COMMANDS.OPEN_FILE.id
        });
        menus.registerMenuAction(browser_2.EditorContextMenu.NAVIGATION, {
            commandId: GIT_COMMANDS.OPEN_CHANGES.id
        });
        [GIT_COMMANDS.STASH, GIT_COMMANDS.APPLY_STASH,
            GIT_COMMANDS.APPLY_LATEST_STASH, GIT_COMMANDS.POP_STASH,
            GIT_COMMANDS.POP_LATEST_STASH, GIT_COMMANDS.DROP_STASH].forEach(function (command) {
            return menus.registerMenuAction(scm_widget_1.ScmWidget.ContextMenu.SECOND_GROUP, {
                commandId: command.id,
                label: command.label
            });
        });
    };
    GitContribution.prototype.registerCommands = function (registry) {
        var _this = this;
        registry.registerCommand(GIT_COMMANDS.FETCH, {
            execute: function () { return _this.quickOpenService.fetch(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.PULL_DEFAULT, {
            execute: function () { return _this.quickOpenService.performDefaultGitAction(git_quick_open_service_1.GitAction.PULL); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.PULL, {
            execute: function () { return _this.quickOpenService.pull(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.PUSH_DEFAULT, {
            execute: function () { return _this.quickOpenService.performDefaultGitAction(git_quick_open_service_1.GitAction.PUSH); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.PUSH, {
            execute: function () { return _this.quickOpenService.push(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.MERGE, {
            execute: function () { return _this.quickOpenService.merge(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.CHECKOUT, {
            execute: function () { return _this.quickOpenService.checkout(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.COMMIT_SIGN_OFF, {
            execute: function () { return _this.gitCommands.doCommit(_this.repositoryTracker.selectedRepository, 'sign-off'); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.COMMIT_AMEND, {
            execute: function () { return __awaiter(_this, void 0, void 0, function () {
                var selectedRepository, message, e_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            selectedRepository = this.repositoryTracker.selectedRepository;
                            if (!!!selectedRepository) return [3 /*break*/, 4];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.quickOpenService.commitMessageForAmend()];
                        case 2:
                            message = _a.sent();
                            this.gitCommands.doCommit(selectedRepository, 'amend', message);
                            return [3 /*break*/, 4];
                        case 3:
                            e_2 = _a.sent();
                            if (!(e_2 instanceof Error) || e_2.message !== 'User abort.') {
                                throw e_2;
                            }
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            }); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.STAGE_ALL, {
            execute: function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    this.gitCommands.stageAll();
                    return [2 /*return*/];
                });
            }); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.UNSTAGE_ALL, {
            execute: function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    this.gitCommands.unstageAll();
                    return [2 /*return*/];
                });
            }); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.DISCARD_ALL, {
            execute: function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    this.gitCommands.discardAll();
                    return [2 /*return*/];
                });
            }); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.CHANGE_REPOSITORY, {
            execute: function () { return _this.quickOpenService.changeRepository(); },
            isEnabled: function () { return _this.hasMultipleRepositories(); }
        });
        registry.registerCommand(GIT_COMMANDS.OPEN_FILE, {
            execute: function (widget) { return _this.openFile(widget); },
            isEnabled: function (widget) { return !!_this.getOpenFileOptions(widget); },
            isVisible: function (widget) { return !!_this.getOpenFileOptions(widget); }
        });
        registry.registerCommand(GIT_COMMANDS.OPEN_CHANGES, {
            execute: function (widget) { return _this.openChanges(widget); },
            isEnabled: function (widget) { return !!_this.getOpenChangesOptions(widget); },
            isVisible: function (widget) { return !!_this.getOpenChangesOptions(widget); }
        });
        registry.registerCommand(GIT_COMMANDS.SYNC, {
            execute: function () { return _this.syncService.sync(); },
            isEnabled: function () { return _this.syncService.canSync(); },
            isVisible: function () { return _this.syncService.canSync(); }
        });
        registry.registerCommand(GIT_COMMANDS.PUBLISH, {
            execute: function () { return _this.syncService.publish(); },
            isEnabled: function () { return _this.syncService.canPublish(); },
            isVisible: function () { return _this.syncService.canPublish(); }
        });
        registry.registerCommand(GIT_COMMANDS.CLONE, {
            isEnabled: function () { return _this.workspaceService.opened; },
            // tslint:disable-next-line:no-any
            execute: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _a;
                var url = undefined;
                var folder = undefined;
                var branch = undefined;
                if (args) {
                    _a = __read(args, 3), url = _a[0], folder = _a[1], branch = _a[2];
                }
                return _this.quickOpenService.clone(url, folder, branch);
            }
        });
        var commit = function () {
            var scmRepository = _this.scmService.selectedRepository;
            if (scmRepository) {
                var localUri = scmRepository.provider.rootUri;
                var message = scmRepository.input.value;
                if (localUri) {
                    _this.gitCommands.doCommit({ localUri: localUri }, undefined, message);
                }
            }
        };
        registry.registerCommand(GIT_COMMANDS.COMMIT, {
            // tslint:disable-next-line:no-any
            execute: function () {
                commit();
            }
        });
        var refresh = function () {
            _this.repositoryProvider.refresh();
        };
        registry.registerCommand(GIT_COMMANDS.REFRESH, {
            // tslint:disable-next-line:no-any
            execute: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                refresh();
            }
        });
        var doSignOff = function () { return __awaiter(_this, void 0, void 0, function () {
            var selectedRepository, _a, username, email, signOff, commitTextArea, content;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        selectedRepository = this.repositoryProvider.selectedRepository;
                        if (!selectedRepository) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.gitCommands.getUserConfig(selectedRepository)];
                    case 1:
                        _a = __read.apply(void 0, [_b.sent(), 2]), username = _a[0], email = _a[1];
                        signOff = "\n\nSigned-off-by: " + username + " <" + email + ">";
                        commitTextArea = document.getElementById(scm_widget_1.ScmWidget.Styles.INPUT_MESSAGE);
                        if (commitTextArea) {
                            content = commitTextArea.value;
                            if (content.endsWith(signOff)) {
                                commitTextArea.value = content.substr(0, content.length - signOff.length);
                            }
                            else {
                                commitTextArea.value = "" + content + signOff;
                            }
                            this.scmWidget.resize(commitTextArea);
                            commitTextArea.focus();
                        }
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        }); };
        registry.registerCommand(GIT_COMMANDS.COMMIT_ADD_SIGN_OFF, {
            // tslint:disable-next-line:no-any
            execute: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                doSignOff();
            }
        });
        var unstage = function (uri) { return __awaiter(_this, void 0, void 0, function () {
            var repository, status_2, gitChange;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        repository = this.repositoryProvider.selectedRepository;
                        if (!repository) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.git.status(repository)];
                    case 1:
                        status_2 = _a.sent();
                        gitChange = status_2.changes.find(function (change) { return change.uri === uri; });
                        if (gitChange) {
                            this.gitCommands.unstage(repository, gitChange);
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        }); };
        registry.registerCommand(GIT_COMMANDS.UNSTAGE, {
            // tslint:disable-next-line:no-any
            execute: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                unstage(args[0].uri);
            }
        });
        var stage = function (uri) { return __awaiter(_this, void 0, void 0, function () {
            var repository, status_3, gitChange;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        repository = this.repositoryProvider.selectedRepository;
                        if (!repository) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.git.status(repository)];
                    case 1:
                        status_3 = _a.sent();
                        gitChange = status_3.changes.find(function (change) { return change.uri === uri; });
                        if (gitChange) {
                            this.gitCommands.stage(repository, gitChange);
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        }); };
        registry.registerCommand(GIT_COMMANDS.STAGE, {
            // tslint:disable-next-line:no-any
            execute: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                stage(args[0].uri);
            }
        });
        var discard = function (uri) { return __awaiter(_this, void 0, void 0, function () {
            var repository, status_4, gitChange;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        repository = this.repositoryProvider.selectedRepository;
                        if (!repository) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.git.status(repository)];
                    case 1:
                        status_4 = _a.sent();
                        gitChange = status_4.changes.find(function (change) { return change.uri === uri; });
                        if (gitChange) {
                            this.gitCommands.discard(repository, gitChange);
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        }); };
        registry.registerCommand(GIT_COMMANDS.DISCARD, {
            // tslint:disable-next-line:no-any
            execute: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                discard(args[0].uri);
            }
        });
        var open = function (uri) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.gitCommands.openFile(new uri_1.default(uri));
                return [2 /*return*/];
            });
        }); };
        registry.registerCommand(GIT_COMMANDS.OPEN_CHANGED_FILE, {
            // tslint:disable-next-line:no-any
            execute: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                open(args[0].uri);
            }
        });
        registry.registerCommand(GIT_COMMANDS.STASH, {
            execute: function () { return _this.quickOpenService.stash(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository &&
                !!_this.repositoryTracker.selectedRepositoryStatus &&
                _this.repositoryTracker.selectedRepositoryStatus.changes.length > 0; }
        });
        registry.registerCommand(GIT_COMMANDS.APPLY_STASH, {
            execute: function () { return _this.quickOpenService.applyStash(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.APPLY_LATEST_STASH, {
            execute: function () { return _this.quickOpenService.applyLatestStash(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.POP_STASH, {
            execute: function () { return _this.quickOpenService.popStash(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.POP_LATEST_STASH, {
            execute: function () { return _this.quickOpenService.popLatestStash(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
        registry.registerCommand(GIT_COMMANDS.DROP_STASH, {
            execute: function () { return _this.quickOpenService.dropStash(); },
            isEnabled: function () { return !!_this.repositoryTracker.selectedRepository; }
        });
    };
    GitContribution.prototype.registerToolbarItems = function (registry) {
        registry.registerItem({
            id: GIT_COMMANDS.OPEN_FILE.id,
            command: GIT_COMMANDS.OPEN_FILE.id,
            tooltip: GIT_COMMANDS.OPEN_FILE.label
        });
        registry.registerItem({
            id: GIT_COMMANDS.OPEN_CHANGES.id,
            command: GIT_COMMANDS.OPEN_CHANGES.id,
            tooltip: GIT_COMMANDS.OPEN_CHANGES.label
        });
    };
    GitContribution.prototype.hasConflicts = function (changes) {
        return changes.some(function (c) { return c.status === common_1.GitFileStatus.Conflicted; });
    };
    GitContribution.prototype.allStaged = function (changes) {
        return !changes.some(function (c) { return !c.staged; });
    };
    GitContribution.prototype.openFile = function (widget) {
        return __awaiter(this, void 0, void 0, function () {
            var options;
            return __generator(this, function (_a) {
                options = this.getOpenFileOptions(widget);
                return [2 /*return*/, options && this.editorManager.open(options.uri, options.options)];
            });
        });
    };
    GitContribution.prototype.getOpenFileOptions = function (widget) {
        var ref = widget ? widget : this.editorManager.currentEditor;
        if (ref instanceof browser_2.EditorWidget && browser_1.DiffUris.isDiffUri(ref.editor.uri)) {
            var _a = __read(browser_1.DiffUris.decode(ref.editor.uri), 2), right = _a[1];
            var uri = right.withScheme('file');
            var selection = ref.editor.selection;
            return { uri: uri, options: { selection: selection, widgetOptions: { ref: ref } } };
        }
        return undefined;
    };
    GitContribution.prototype.openChanges = function (widget) {
        return __awaiter(this, void 0, void 0, function () {
            var options;
            return __generator(this, function (_a) {
                options = this.getOpenChangesOptions(widget);
                if (options) {
                    return [2 /*return*/, this.gitCommands.openChange(options.change, options.options)];
                }
                return [2 /*return*/, undefined];
            });
        });
    };
    GitContribution.prototype.getOpenChangesOptions = function (widget) {
        var ref = widget ? widget : this.editorManager.currentEditor;
        if (ref instanceof browser_2.EditorWidget && !browser_1.DiffUris.isDiffUri(ref.editor.uri)) {
            var uri = ref.editor.uri;
            var change = this.gitCommands.findChange(uri);
            if (change && this.gitCommands.getUriToOpen(change).toString() !== uri.toString()) {
                var selection = ref.editor.selection;
                return { change: change, options: { selection: selection, widgetOptions: { ref: ref } } };
            }
        }
        return undefined;
    };
    GitContribution.prototype.hasMultipleRepositories = function () {
        return this.repositoryTracker.allRepositories.length > 1;
    };
    GitContribution.prototype.updateSyncStatusBarEntry = function (repositoryUri) {
        var entry = this.getStatusBarEntry();
        if (entry && repositoryUri) {
            var scmProvider = this.scmProviders.find(function (provider) { return provider.rootUri === repositoryUri; });
            if (scmProvider) {
                scmProvider.fireChangeStatusBarCommands([{
                        id: GitContribution_1.GIT_SYNC_STATUS,
                        text: entry.text,
                        tooltip: entry.tooltip,
                        command: entry.command,
                    }]);
            }
        }
        else {
            this.statusBar.removeElement(GitContribution_1.GIT_SYNC_STATUS);
        }
    };
    GitContribution.prototype.getStatusBarEntry = function () {
        var status = this.repositoryTracker.selectedRepositoryStatus;
        if (!status || !status.branch) {
            return undefined;
        }
        if (this.syncService.isSyncing()) {
            return {
                text: '$(refresh~spin)',
                tooltip: 'Synchronizing Changes...'
            };
        }
        var upstreamBranch = status.upstreamBranch, aheadBehind = status.aheadBehind;
        if (upstreamBranch) {
            return {
                text: '$(refresh)' + (aheadBehind && (aheadBehind.ahead + aheadBehind.behind) > 0 ? " " + aheadBehind.behind + "\u2193 " + aheadBehind.ahead + "\u2191" : ''),
                command: GIT_COMMANDS.SYNC.id,
                tooltip: 'Synchronize Changes'
            };
        }
        return {
            text: '$(cloud-upload)',
            command: GIT_COMMANDS.PUBLISH.id,
            tooltip: 'Publish Changes'
        };
    };
    GitContribution.prototype.registerScmTitleCommands = function (registry) {
        registry.registerItem({ command: GIT_COMMANDS.REFRESH.id, group: 'navigation' });
        registry.registerItem({ command: GIT_COMMANDS.COMMIT_ADD_SIGN_OFF.id, group: 'navigation' });
    };
    GitContribution.prototype.registerScmResourceCommands = function (registry) {
        registry.registerItems('Changes', [
            {
                command: GIT_COMMANDS.OPEN_CHANGED_FILE.id,
                group: 'navigation'
            },
            {
                command: GIT_COMMANDS.DISCARD.id,
                group: 'navigation'
            },
            {
                command: GIT_COMMANDS.STAGE.id,
                group: 'navigation'
            }
        ]);
        registry.registerItems('Staged changes', [
            {
                command: GIT_COMMANDS.OPEN_CHANGED_FILE.id,
                group: 'navigation'
            },
            {
                command: GIT_COMMANDS.UNSTAGE.id,
                group: 'navigation'
            }
        ]);
        registry.registerItems('Merged Changes', [
            {
                command: GIT_COMMANDS.OPEN_CHANGED_FILE.id,
                group: 'navigation'
            },
            {
                command: GIT_COMMANDS.DISCARD.id,
                group: 'navigation'
            },
            {
                command: GIT_COMMANDS.STAGE.id,
                group: 'navigation'
            }
        ]);
    };
    GitContribution.prototype.registerScmGroupCommands = function (registry) {
        registry.registerItems('Changes', [
            {
                command: GIT_COMMANDS.DISCARD_ALL.id,
                group: 'inline'
            },
            {
                command: GIT_COMMANDS.STAGE_ALL.id,
                group: 'inline'
            }
        ]);
        registry.registerItems('Staged changes', [{ command: GIT_COMMANDS.UNSTAGE_ALL.id, group: 'inline' }]);
        registry.registerItems('Merged Changes', [{ command: GIT_COMMANDS.STAGE_ALL.id, group: 'inline' }]);
    };
    var GitContribution_1;
    GitContribution.GIT_CHECKOUT = 'git.checkout';
    GitContribution.GIT_SYNC_STATUS = 'git-sync-status';
    __decorate([
        inversify_1.inject(browser_1.StatusBar),
        __metadata("design:type", Object)
    ], GitContribution.prototype, "statusBar", void 0);
    __decorate([
        inversify_1.inject(browser_2.EditorManager),
        __metadata("design:type", browser_2.EditorManager)
    ], GitContribution.prototype, "editorManager", void 0);
    __decorate([
        inversify_1.inject(git_quick_open_service_1.GitQuickOpenService),
        __metadata("design:type", git_quick_open_service_1.GitQuickOpenService)
    ], GitContribution.prototype, "quickOpenService", void 0);
    __decorate([
        inversify_1.inject(git_repository_tracker_1.GitRepositoryTracker),
        __metadata("design:type", git_repository_tracker_1.GitRepositoryTracker)
    ], GitContribution.prototype, "repositoryTracker", void 0);
    __decorate([
        inversify_1.inject(git_sync_service_1.GitSyncService),
        __metadata("design:type", git_sync_service_1.GitSyncService)
    ], GitContribution.prototype, "syncService", void 0);
    __decorate([
        inversify_1.inject(browser_3.WorkspaceService),
        __metadata("design:type", browser_3.WorkspaceService)
    ], GitContribution.prototype, "workspaceService", void 0);
    __decorate([
        inversify_1.inject(git_prompt_1.GitPrompt),
        __metadata("design:type", git_prompt_1.GitPrompt)
    ], GitContribution.prototype, "prompt", void 0);
    __decorate([
        inversify_1.inject(browser_4.ScmService),
        __metadata("design:type", browser_4.ScmService)
    ], GitContribution.prototype, "scmService", void 0);
    __decorate([
        inversify_1.inject(git_repository_provider_1.GitRepositoryProvider),
        __metadata("design:type", git_repository_provider_1.GitRepositoryProvider)
    ], GitContribution.prototype, "repositoryProvider", void 0);
    __decorate([
        inversify_1.inject(git_commit_message_validator_1.GitCommitMessageValidator),
        __metadata("design:type", git_commit_message_validator_1.GitCommitMessageValidator)
    ], GitContribution.prototype, "commitMessageValidator", void 0);
    __decorate([
        inversify_1.inject(core_1.CommandRegistry),
        __metadata("design:type", core_1.CommandRegistry)
    ], GitContribution.prototype, "commandRegistry", void 0);
    __decorate([
        inversify_1.inject(common_1.Git),
        __metadata("design:type", Object)
    ], GitContribution.prototype, "git", void 0);
    __decorate([
        inversify_1.inject(git_error_handler_1.GitErrorHandler),
        __metadata("design:type", git_error_handler_1.GitErrorHandler)
    ], GitContribution.prototype, "gitErrorHandler", void 0);
    __decorate([
        inversify_1.inject(browser_1.LabelProvider),
        __metadata("design:type", browser_1.LabelProvider)
    ], GitContribution.prototype, "labelProvider", void 0);
    __decorate([
        inversify_1.inject(scm_widget_1.ScmWidget),
        __metadata("design:type", scm_widget_1.ScmWidget)
    ], GitContribution.prototype, "scmWidget", void 0);
    __decorate([
        inversify_1.inject(git_commands_1.GitCommands),
        __metadata("design:type", git_commands_1.GitCommands)
    ], GitContribution.prototype, "gitCommands", void 0);
    GitContribution = GitContribution_1 = __decorate([
        inversify_1.injectable()
    ], GitContribution);
    return GitContribution;
}());
exports.GitContribution = GitContribution;
var ScmProviderImpl = /** @class */ (function () {
    function ScmProviderImpl(_contextValue, _label, _rootUri, _amendSupport) {
        this._contextValue = _contextValue;
        this._label = _label;
        this._rootUri = _rootUri;
        this._amendSupport = _amendSupport;
        this.onDidChangeEmitter = new core_1.Emitter();
        this.onDidChangeResourcesEmitter = new core_1.Emitter();
        this.onDidChangeCommitTemplateEmitter = new core_1.Emitter();
        this.onDidChangeStatusBarCommandsEmitter = new core_1.Emitter();
        this.disposableCollection = new core_1.DisposableCollection();
        this.handle = 0;
        this._id = "scm" + ScmProviderImpl.ID++;
        this.disposableCollection.push(this.onDidChangeEmitter);
        this.disposableCollection.push(this.onDidChangeResourcesEmitter);
        this.disposableCollection.push(this.onDidChangeCommitTemplateEmitter);
        this.disposableCollection.push(this.onDidChangeStatusBarCommandsEmitter);
    }
    Object.defineProperty(ScmProviderImpl.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "groups", {
        get: function () {
            return this._groups;
        },
        set: function (groups) {
            this._groups = groups;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "label", {
        get: function () {
            return this._label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "rootUri", {
        get: function () {
            return this._rootUri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "contextValue", {
        get: function () {
            return this._contextValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "onDidChangeResources", {
        get: function () {
            return this.onDidChangeResourcesEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "commitTemplate", {
        get: function () {
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "acceptInputCommand", {
        get: function () {
            return GIT_COMMANDS.COMMIT;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "statusBarCommands", {
        get: function () {
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "count", {
        get: function () {
            return this._count;
        },
        set: function (count) {
            this._count = count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "onDidChangeCommitTemplate", {
        get: function () {
            return this.onDidChangeCommitTemplateEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "onDidChangeStatusBarCommands", {
        get: function () {
            return this.onDidChangeStatusBarCommandsEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScmProviderImpl.prototype, "onDidChange", {
        get: function () {
            return this.onDidChangeEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    ScmProviderImpl.prototype.dispose = function () {
        this.disposableCollection.dispose();
    };
    ScmProviderImpl.prototype.getOriginalResource = function (uri) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, undefined];
            });
        });
    };
    ScmProviderImpl.prototype.fireChangeStatusBarCommands = function (commands) {
        this.onDidChangeStatusBarCommandsEmitter.fire(commands);
    };
    ScmProviderImpl.prototype.fireChangeResources = function () {
        this.onDidChangeResourcesEmitter.fire(undefined);
    };
    ScmProviderImpl.prototype.fireChange = function () {
        this.onDidChangeEmitter.fire(undefined);
    };
    Object.defineProperty(ScmProviderImpl.prototype, "amendSupport", {
        get: function () {
            return this._amendSupport;
        },
        enumerable: true,
        configurable: true
    });
    ScmProviderImpl.ID = 0;
    return ScmProviderImpl;
}());
exports.ScmProviderImpl = ScmProviderImpl;
var GitAmendSupport = /** @class */ (function () {
    function GitAmendSupport(repository, git) {
        this.repository = repository;
        this.git = git;
    }
    GitAmendSupport.prototype.getInitialAmendingCommits = function (amendingHeadCommitSha, latestCommitSha) {
        return __awaiter(this, void 0, void 0, function () {
            var commits;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.git.log(this.repository, {
                            range: { toRevision: amendingHeadCommitSha, fromRevision: latestCommitSha },
                            maxCount: 50
                        })];
                    case 1:
                        commits = _a.sent();
                        return [2 /*return*/, commits.map(this.createScmCommit)];
                }
            });
        });
    };
    GitAmendSupport.prototype.getMessage = function (commit) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.git.exec(this.repository, ['log', '-n', '1', '--format=%B', commit])];
                    case 1: return [2 /*return*/, (_a.sent()).stdout.trim()];
                }
            });
        });
    };
    GitAmendSupport.prototype.reset = function (commit) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.git.exec(this.repository, ['reset', commit, '--soft'])];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    GitAmendSupport.prototype.getLastCommit = function () {
        return __awaiter(this, void 0, void 0, function () {
            var commits;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.git.log(this.repository, { maxCount: 1 })];
                    case 1:
                        commits = _a.sent();
                        if (commits.length > 0) {
                            return [2 /*return*/, this.createScmCommit(commits[0])];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    GitAmendSupport.prototype.createScmCommit = function (gitCommit) {
        return {
            id: gitCommit.sha,
            summary: gitCommit.summary,
            authorName: gitCommit.author.name,
            authorEmail: gitCommit.author.email,
            authorDateRelative: gitCommit.authorDateRelative
        };
    };
    return GitAmendSupport;
}());
exports.GitAmendSupport = GitAmendSupport;
//# sourceMappingURL=git-contribution.js.map